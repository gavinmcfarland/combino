import { Combino } from '../../dist/index.js';
import path from 'path';
import { fileURLToPath } from 'url';
import fs from 'fs/promises';
import chalk from 'chalk';
import { stripTSFromString } from 'strip-ts';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

// Hardcoded choices based on available templates
const FRAMEWORKS = ['react', 'svelte']; // Excluding 'vue' as requested
const TYPES = ['plugin', 'widget'];
const TYPESCRIPT_OPTIONS = [true, false];

// Available examples for each type - can be easily modified to disable types
const EXAMPLES = {
	plugin: ['basic', 'minimal'],
	// widget: ['sticky-note']
};

// Helper function to get enabled types and their examples
function getEnabledTypes() {
	return Object.entries(EXAMPLES)
		.filter(([type, examples]) => examples.length > 0)
		.map(([type, examples]) => ({ type, examples }));
}

// Helper function to clear directory if it exists
async function clearDirectory(dirPath) {
	try {
		await fs.rm(dirPath, { recursive: true, force: true });
		console.log(chalk.yellow(`Cleared existing directory: ${dirPath}`));
	} catch (error) {
		// Directory doesn't exist, which is fine
	}
}

// Helper function to generate a descriptive name
function generateName(framework, type, example, typescript) {
	const langSuffix = typescript ? '-ts' : '-js';
	return `${example}-${framework}-${type}${langSuffix}`;
}

// Helper function to add source file path comments to generated files
async function addSourceFileComments(outputDir, templates) {
	console.log(chalk.gray('   üîç Adding source file tracking...'));

	// Recursively find all files in the output directory
	const files = await findFilesRecursively(outputDir);

	for (const file of files) {
		try {
			const content = await fs.readFile(file, 'utf-8');
			const ext = path.extname(file).toLowerCase();
			const relativePath = path.relative(outputDir, file);

			// Find which template contains this file
			let sourceTemplate = null;
			let sourceTemplateName = '';

			// Check each template in reverse order (last template wins)
			for (let i = templates.length - 1; i >= 0; i--) {
				const template = templates[i];
				const potentialSource = path.join(template, relativePath);
				try {
					await fs.access(potentialSource);
					sourceTemplate = potentialSource;
					sourceTemplateName = path.basename(template);
					break;
				} catch {
					// File doesn't exist in this template, continue to next
				}
			}

			if (sourceTemplate) {
				let commentedContent = content;
				const relativeSourcePath = path.relative(__dirname, sourceTemplate);

				// Add source file comment based on file type
				switch (ext) {
					case '.js':
					case '.ts':
					case '.jsx':
					case '.tsx':
					case '.svelte':
					case '.vue':
						// Check if file already has a source comment
						if (!content.includes('// Source:')) {
							commentedContent = `// Source: ${relativeSourcePath}\n${content}`;
						}
						break;
					case '.json':
						// For JSON files, we can't add comments, but we can log the source
						console.log(chalk.gray(`     üìÑ ${relativePath} <- ${relativeSourcePath}`));
						break;
					case '.md':
						if (!content.includes('<!-- Source:')) {
							commentedContent = `<!-- Source: ${relativeSourcePath} -->\n\n${content}`;
						}
						break;
					case '.html':
					case '.htm':
						if (!content.includes('<!-- Source:')) {
							commentedContent = `<!-- Source: ${relativeSourcePath} -->\n${content}`;
						}
						break;
					case '.css':
					case '.scss':
					case '.sass':
						if (!content.includes('/* Source:')) {
							commentedContent = `/* Source: ${relativeSourcePath} */\n${content}`;
						}
						break;
					default:
						// For other file types, just log the source
						console.log(chalk.gray(`     üìÑ ${relativePath} <- ${relativeSourcePath}`));
				}

				// Write the commented content back to the file
				if (commentedContent !== content) {
					await fs.writeFile(file, commentedContent);
					console.log(chalk.gray(`     ‚úèÔ∏è  Added source comment to ${relativePath}`));
				}
			} else {
				// File not found in any template (might be generated by Combino)
				console.log(chalk.yellow(`     ‚ö†Ô∏è  Could not find source for ${relativePath}`));
			}
		} catch (error) {
			// Ignore errors when adding comments
			console.log(chalk.yellow(`     ‚ö†Ô∏è  Could not add source comment to ${file}: ${error.message}`));
		}
	}
}

// Helper function to recursively find all files in a directory
async function findFilesRecursively(dir) {
	const files = [];

	async function scan(currentDir) {
		const items = await fs.readdir(currentDir, { withFileTypes: true });

		for (const item of items) {
			const fullPath = path.join(currentDir, item.name);

			if (item.isDirectory()) {
				// Skip node_modules and other common directories
				if (item.name === 'node_modules' || item.name === '.git' || item.name === '.combino') {
					continue;
				}
				await scan(fullPath);
			} else {
				files.push(fullPath);
			}
		}
	}

	await scan(dir);
	return files;
}

async function generateAllCombinations() {
	const combino = new Combino();
	const outputBaseDir = path.join(__dirname, 'output');

	// Clear the entire output directory
	await clearDirectory(outputBaseDir);

	console.log(chalk.blue('üöÄ Starting automated generation of all combinations...\n'));

	let totalCombinations = 0;
	let successfulGenerations = 0;
	let failedGenerations = 0;

	// Generate all combinations
	for (const framework of FRAMEWORKS) {
		for (const { type, examples } of getEnabledTypes()) {
			for (const example of examples) {
				for (const typescript of TYPESCRIPT_OPTIONS) {
					totalCombinations++;

					const name = generateName(framework, type, example, typescript);
					const outputDir = path.join(outputBaseDir, name);

					console.log(chalk.cyan(`\nüì¶ Generating: ${name}`));
					console.log(chalk.gray(`   Framework: ${framework}`));
					console.log(chalk.gray(`   Type: ${type}`));
					console.log(chalk.gray(`   Example: ${example}`));
					console.log(chalk.gray(`   TypeScript: ${typescript}`));

					try {
						// Prepare template paths based on choices
						const templates = [];

						// Add example template
						templates.push(path.join(__dirname, `templates/examples/${type}/${example}`));

						// Add framework template
						templates.push(path.join(__dirname, `templates/frameworks/${framework}`));

						// Add TypeScript template if needed
						if (typescript) {
							templates.push(path.join(__dirname, "templates/typescript"));
						}

						// Generate the project
						await combino.combine({
							outputDir,
							include: templates,
							templateEngine: 'ejs',
							data: {
								framework,
								language: typescript ? 'ts' : 'js',
								name,
								description: `A Figma ${type} with ${framework} and ${typescript ? 'TypeScript' : 'JavaScript'}`,
								typescript: typescript
							},
							onFileProcessed: async (context) => {
								const { targetPath, content, data } = context;

								// Add a comment to all JavaScript files
								if (targetPath.endsWith(".js")) {
									return `// Generated by Combino\n${content}`;
								}

								// If TypeScript is disabled, strip TypeScript annotations from relevant files
								if (!data.typescript) {
									const ext = path.extname(targetPath).toLowerCase();

									// Check if this is a TypeScript file that should be converted
									if (ext === '.ts' || ext === '.tsx' || ext === '.vue' || ext === '.svelte') {
										try {
											// Map file extension to file type for strip-ts
											let fileType;
											if (ext === '.ts') {
												// Skip .d.ts files and config files as they're not supported
												if (targetPath.endsWith('.d.ts') ||
													targetPath.includes('config') ||
													targetPath.includes('vite-env')) {
													return content;
												}
												fileType = 'typescript';
											}
											else if (ext === '.tsx') fileType = 'tsx';
											else if (ext === '.vue') fileType = 'vue';
											else if (ext === '.svelte') fileType = 'svelte';

											// Process content directly with strip-ts
											const processedContent = await stripTSFromString(content, fileType);

											if (processedContent && processedContent !== content) {
												// Update the target path to use .js extension for .ts files
												if (ext === '.ts') {
													context.targetPath = targetPath.replace('.ts', '.js');
												} else if (ext === '.tsx') {
													context.targetPath = targetPath.replace('.tsx', '.jsx');
												}

												console.log(
													chalk.gray(`     üîÑ Stripped TypeScript from ${path.basename(targetPath)}`)
												);

												return processedContent;
											}
										} catch (error) {
											// Log the error but don't fail the build
											console.log(
												chalk.yellow(
													`     ‚ö†Ô∏è  Failed to strip TypeScript from ${path.basename(targetPath)}: ${error.message}`
												)
											);
											// Return original content to continue processing
											return content;
										}
									}
								}

								return content;
							},
						});

						// Add source file path comments to generated files
						await addSourceFileComments(outputDir, templates);

						console.log(chalk.green(`   ‚úÖ Successfully generated: ${name}`));
						successfulGenerations++;

					} catch (error) {
						console.log(chalk.red(`   ‚ùå Failed to generate: ${name}`));
						console.log(chalk.red(`   Output directory: ${outputDir}`));
						console.log(chalk.red(`   Error: ${error.message}`));

						// Log the template paths that were being processed
						console.log(chalk.yellow(`   Template paths being processed:`));
						const templates = [];
						templates.push(path.join(__dirname, `templates/examples/${type}/${example}`));
						templates.push(path.join(__dirname, `templates/frameworks/${framework}`));
						if (typescript) {
							templates.push(path.join(__dirname, "templates/typescript"));
						}
						templates.forEach((template, index) => {
							console.log(chalk.yellow(`     ${index + 1}. ${template}`));
						});

						// Log detailed error information including stack trace
						if (error.stack) {
							console.log(chalk.red(`   Error stack trace:`));
							const stackLines = error.stack.split('\n');
							// Look for lines that reference template files
							const templateErrorLines = stackLines.filter(line =>
								line.includes('templates/') ||
								line.includes('combino') ||
								line.includes('combine')
							);
							templateErrorLines.forEach(line => {
								console.log(chalk.red(`     ${line.trim()}`));
							});
						}

						// If the output directory was created, log its contents to help debug
						try {
							const files = await fs.readdir(outputDir);
							if (files.length > 0) {
								console.log(chalk.yellow(`   Files created before error:`));
								files.forEach(file => {
									console.log(chalk.yellow(`     - ${file}`));
								});
							}
						} catch (dirError) {
							// Directory doesn't exist or can't be read
						}

						failedGenerations++;
					}
				}
			}
		}
	}

	// Summary
	console.log(chalk.blue('\nüìä Generation Summary:'));
	console.log(chalk.white(`   Total combinations: ${totalCombinations}`));
	console.log(chalk.green(`   Successful: ${successfulGenerations}`));
	console.log(chalk.red(`   Failed: ${failedGenerations}`));
	console.log(chalk.blue(`   Output directory: ${outputBaseDir}`));

	// List all generated projects
	console.log(chalk.blue('\nüìÅ Generated Projects:'));
	try {
		const projects = await fs.readdir(outputBaseDir);
		projects.forEach(project => {
			console.log(chalk.white(`   üìÇ ${project}`));
		});
	} catch (error) {
		console.log(chalk.yellow('   No projects generated or output directory not accessible'));
	}
}

// Parse CLI arguments for additional options
function parseArgs() {
	const args = process.argv.slice(2);
	const dryRun = args.includes('--dry-run') || args.includes('-d');
	const verbose = args.includes('--verbose') || args.includes('-v');
	return { dryRun, verbose };
}

async function main() {
	const { dryRun, verbose } = parseArgs();

	if (dryRun) {
		console.log(chalk.yellow('üîç DRY RUN MODE - No files will be generated\n'));
		console.log(chalk.blue('Combinations that would be generated:'));

		let count = 0;
		for (const framework of FRAMEWORKS) {
			for (const { type, examples } of getEnabledTypes()) {
				for (const example of examples) {
					for (const typescript of TYPESCRIPT_OPTIONS) {
						count++;
						const name = generateName(framework, type, example, typescript);
						console.log(chalk.white(`   ${count}. ${name}`));
					}
				}
			}
		}

		console.log(chalk.blue(`\nTotal combinations: ${count}`));
		return;
	}

	if (verbose) {
		console.log(chalk.blue('Available choices:'));
		console.log(chalk.white(`   Frameworks: ${FRAMEWORKS.join(', ')}`));
		console.log(chalk.white(`   Enabled Types: ${getEnabledTypes().map(t => t.type).join(', ')}`));
		console.log(chalk.white(`   TypeScript options: ${TYPESCRIPT_OPTIONS.join(', ')}`));
		console.log(chalk.white(`   Examples: ${JSON.stringify(EXAMPLES, null, 2)}`));
		console.log('');
	}

	await generateAllCombinations();
}

main().catch(error => {
	console.error(chalk.red('Fatal error:'), error);
	process.exit(1);
});
